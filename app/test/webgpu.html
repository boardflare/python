<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Levenshtein Distance with WebGPU</title>
</head>

<body>
    <script type="module">
        async function initWebGPU() {
            if (!navigator.gpu) {
                console.error("WebGPU not supported on this browser.");
                return;
            }
            console.log("WebGPU is supported.");

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                console.error("Failed to get GPU adapter.");
                return;
            }
            console.log("GPU adapter acquired.");

            const device = await adapter.requestDevice();
            if (!device) {
                console.error("Failed to get GPU device.");
                return;
            }
            console.log("GPU device acquired.");

            const shaderCode = `
                @group(0) @binding(0) var<storage, read> str1 : array<u32>;
                @group(0) @binding(1) var<storage, read> str2 : array<u32>;
                @group(0) @binding(2) var<storage, read_write> distMatrix : array<u32>;
                @group(0) @binding(3) var<uniform> str1Length : u32;
                @group(0) @binding(4) var<uniform> str2Length : u32;

                @compute @workgroup_size(1)
                fn main(@builtin(global_invocation_id) id : vec3<u32>) {
                    let i = id.x;
                    let j = id.y;
                    let width = str2Length + 1;

                    if (i == 0) {
                        distMatrix[j] = j;
                    } else if (j == 0) {
                        distMatrix[i * width] = i;
                    } else {
                        let cost = select(1u, 0u, str1[i - 1] == str2[j - 1]);
                        let insert = distMatrix[i * width + j - 1] + 1;
                        let del = distMatrix[(i - 1) * width + j] + 1;
                        let replace = distMatrix[(i - 1) * width + j - 1] + cost;
                        distMatrix[i * width + j] = min(insert, min(del, replace));
                    }
                }
            `;

            const shaderModule = device.createShaderModule({ code: shaderCode });
            console.log("Shader module created.");

            const str1 = "kite";
            const str2 = "sitting";
            const str1Buffer = device.createBuffer({
                size: str1.length * 4,
                usage: GPUBufferUsage.STORAGE,
                mappedAtCreation: true
            });
            new Uint32Array(str1Buffer.getMappedRange()).set([...str1].map(c => c.charCodeAt(0)));
            str1Buffer.unmap();
            console.log("str1Buffer created and unmapped.");

            const str2Buffer = device.createBuffer({
                size: str2.length * 4,
                usage: GPUBufferUsage.STORAGE,
                mappedAtCreation: true
            });
            new Uint32Array(str2Buffer.getMappedRange()).set([...str2].map(c => c.charCodeAt(0)));
            str2Buffer.unmap();
            console.log("str2Buffer created and unmapped.");

            const distMatrixBuffer = device.createBuffer({
                size: (str1.length + 1) * (str2.length + 1) * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
            });
            console.log("distMatrixBuffer created.");

            const str1LengthBuffer = device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.UNIFORM,
                mappedAtCreation: true
            });
            new Uint32Array(str1LengthBuffer.getMappedRange())[0] = str1.length;
            str1LengthBuffer.unmap();
            console.log("str1LengthBuffer created and unmapped.");

            const str2LengthBuffer = device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.UNIFORM,
                mappedAtCreation: true
            });
            new Uint32Array(str2LengthBuffer.getMappedRange())[0] = str2.length;
            str2LengthBuffer.unmap();
            console.log("str2LengthBuffer created and unmapped.");

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
                    { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }
                ]
            });
            console.log("Bind group layout created.");

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: str1Buffer } },
                    { binding: 1, resource: { buffer: str2Buffer } },
                    { binding: 2, resource: { buffer: distMatrixBuffer } },
                    { binding: 3, resource: { buffer: str1LengthBuffer } },
                    { binding: 4, resource: { buffer: str2LengthBuffer } }
                ]
            });
            console.log("Bind group created.");

            const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
            console.log("Pipeline layout created.");

            const computePipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: {
                    module: shaderModule,
                    entryPoint: "main"
                }
            });
            console.log("Compute pipeline created.");

            const commandEncoder = device.createCommandEncoder();
            const passEncoder = commandEncoder.beginComputePass();
            passEncoder.setPipeline(computePipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.dispatchWorkgroups(str1.length + 1, str2.length + 1);
            passEncoder.end();
            console.log("Compute pass dispatched.");

            const gpuReadBuffer = device.createBuffer({
                size: (str1.length + 1) * (str2.length + 1) * 4,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
            console.log("gpuReadBuffer created.");

            commandEncoder.copyBufferToBuffer(distMatrixBuffer, 0, gpuReadBuffer, 0, (str1.length + 1) * (str2.length + 1) * 4);

            const commands = commandEncoder.finish();
            device.queue.submit([commands]);
            console.log("Commands submitted.");

            await gpuReadBuffer.mapAsync(GPUMapMode.READ);
            const arrayBuffer = gpuReadBuffer.getMappedRange();
            const result = new Uint32Array(arrayBuffer);

            console.log("Distance Matrix:", result);
            console.log("Levenshtein Distance:", result[str1.length * (str2.length + 1) + str2.length]);
        }

        initWebGPU();
    </script>
</body>

</html>