[
  {
    "name": "ai_ask",
    "description": "Uses AI to generate responses based on prompts and optional data ranges.",
    "code": "import requests\nimport json\n\ndef ai_ask(prompt, data=None, temperature=0.5, max_tokens=250, model='mistral-small-latest'):\n    \"\"\"\n    Uses AI to generate responses based on prompts and optional data ranges.\n\n    Args:\n        prompt (str): The question, task, or analysis to perform\n        data (list, optional): 2D list containing data from Excel range to analyze\n        temperature (float, optional): Controls response creativity (0-2). Default is 0.5\n        max_tokens (int, optional): Maximum tokens for response generation\n        model (str, optional): ID of the model to use\n        # Note: API key is hardcoded for this example, replace with secure handling in production\n\n    Returns:\n        str: The AI-generated response\n    \"\"\"\n    \n    # Using Boardflare API for demo purposes. Replace with any OpenAI compatible API endpoint.\n    # Sign up for your free Mistral API account at https://console.mistral.ai/ then replace the following:\n    \n    api_url = \"https://llm.boardflare.com\" # replace with \"https://api.mistral.ai/v1/chat/completions\"\n    api_key = \"cV4a59t1wjYGs....\" # replace with your Mistral API key\n    \n    # Construct the message incorporating both prompt and data if provided\n    message = prompt\n    if data is not None:\n        data_str = json.dumps(data, indent=2)\n        message += f\"\\n\\nData to analyze:\\n{data_str}\"\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": message}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": max_tokens\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    # Make the API request\n    response = requests.post(api_url, headers=headers, json=payload)\n    response.raise_for_status()\n    \n    # Extract and return the response content\n    response_data = response.json()\n    content = response_data[\"choices\"][0][\"message\"][\"content\"]\n\n    return content",
    "test_cases": [
      {
        "id": "test_hr_engagement_summary",
        "description": "HR: Summarize employee engagement survey results.",
        "arguments": {
          "prompt": "Summarize the key findings from the employee engagement survey:",
          "data": [
            [
              "Question",
              "Score"
            ],
            [
              "Team collaboration",
              4.5
            ],
            [
              "Workload",
              3.2
            ],
            [
              "Career advancement",
              3.0
            ],
            [
              "Management support",
              4.0
            ]
          ]
        },
        "expected_contains_any": [
          "collaboration",
          "workload",
          "career"
        ],
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_sales_quarterly_analysis",
        "description": "Sales: Analyze quarterly sales data and provide insights.",
        "arguments": {
          "prompt": "Provide a brief analysis of the quarterly sales performance:",
          "data": [
            [
              "Region",
              "Q1",
              "Q2",
              "Q3",
              "Q4"
            ],
            [
              "North",
              120,
              135,
              150,
              160
            ],
            [
              "South",
              100,
              110,
              120,
              130
            ],
            [
              "Central",
              90,
              95,
              100,
              105
            ]
          ]
        },
        "expected_contains_any": [
          "North",
          "growth",
          "sales"
        ],
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_operations_incident_summary",
        "description": "Operations: Summarize an incident report.",
        "arguments": {
          "prompt": "Summarize the following incident report in one sentence:",
          "data": [
            [
              "On April 10th, a system outage affected order processing for 2 hours. The IT team resolved the issue by updating server configurations. No data loss occurred."
            ]
          ]
        },
        "expected_contains_any": [
          "outage",
          "resolved",
          "data loss"
        ],
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_business_followup_email",
        "description": "Business Writing: Draft a customer follow-up email.",
        "arguments": {
          "prompt": "Draft a follow-up email to a client after a successful product demo."
        },
        "expected_contains_any_lower": [
          "thank you",
          "product",
          "next steps"
        ],
        "expected_rows": 1,
        "demo": true
      }
    ],
    "fileId": "2",
    "link": "https://www.boardflare.com/resources/python-functions/text\\ai_ask/ai_ask"
  },
  {
    "name": "ai_choice",
    "description": "Uses AI to select the most appropriate choice from a list of options based on the given context.",
    "code": "import requests\nimport json\n\ndef ai_choice(text, choices, temperature=0.2, model='mistral-small-latest'):\n    \"\"\"\n    Uses AI to select the most appropriate choice from a list of options based on the given context.\n    \n    Args:\n        text (str or list): The context, question, or scenario used for decision-making\n        choices (str or list): A string with comma-separated options or a 2D list of options\n        temperature (float, optional): Controls randomness in the selection (0-1). Default is 0.2\n        model (str, optional): ID of the AI model to use\n        \n    Returns:\n        str: The selected choice from the options provided\n    \"\"\"\n    # Input validation\n    if not text or (isinstance(text, list) and (len(text) == 0 or len(text[0]) == 0)):\n        return \"Error: Empty input text.\"\n    \n    if not choices or (isinstance(choices, list) and (len(choices) == 0 or len(choices[0]) == 0)):\n        return \"Error: No valid choices provided.\"\n    \n    # Normalize text to string if it's a 2D list\n    if isinstance(text, list):\n        text_str = \"\\n\".join([item[0] if isinstance(item[0], str) else str(item[0]) for item in text if len(item) > 0])\n    else:\n        text_str = text\n    \n    # Normalize choices to a list of strings\n    if isinstance(choices, list):\n        choices_list = [item[0] if isinstance(item, list) and len(item) > 0 else str(item) for item in choices]\n    else:\n        choices_list = [choice.strip() for choice in str(choices).split(',')]\n    \n    # Construct the AI prompt\n    prompt = f\"\"\"Based on the following context, select the single most appropriate option from the choices provided.\n    \nContext:\n{text_str}\n\nChoices:\n{json.dumps(choices_list, indent=2)}\n\nProvide ONLY your selected choice without explanation or additional text. Return the exact text of the selected choice.\"\"\"\n\n    # Using Boardflare API for demo purposes. Replace with any OpenAI compatible API endpoint.\n    # Sign up for your free Mistral API account at https://console.mistral.ai/ then replace the following:\n    \n    api_url = \"https://llm.boardflare.com\" # replace with \"https://api.mistral.ai/v1/chat/completions\"\n    api_key = \"cV4a59t1wjYGs....\" # replace with your Mistral API key\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": prompt}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": 200\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    try:\n        # Make the API request\n        response = requests.post(api_url, headers=headers, json=payload)\n        response.raise_for_status()\n        \n        # Extract and return the response content\n        response_data = response.json()\n        content = response_data[\"choices\"][0][\"message\"][\"content\"].strip()\n        \n        # Validate that the response is one of the choices\n        for choice in choices_list:\n            if choice in content or content in choice:\n                return choice\n        \n        # If no exact match, return the AI's response (which may be a paraphrase)\n        return content\n        \n    except Exception as e:\n        return f\"Error: Failed to get AI recommendation. {str(e)}\"",
    "test_cases": [
      {
        "id": "test_expense_categorization",
        "description": "Finance: Categorize an expense transaction based on its description.",
        "arguments": {
          "text": "Uber ride from airport to hotel, $45.50",
          "choices": [
            [
              "Travel"
            ],
            [
              "Food"
            ],
            [
              "Office"
            ],
            [
              "Software"
            ]
          ]
        },
        "expected_contains": "Travel",
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_customer_email_sentiment",
        "description": "Customer Service: Classify the sentiment of a customer email.",
        "arguments": {
          "text": "I've been waiting for a response about my refund for over two weeks now. This is completely unacceptable and I'm considering filing a complaint.",
          "choices": [
            [
              "Positive"
            ],
            [
              "Neutral"
            ],
            [
              "Negative"
            ]
          ]
        },
        "expected_contains": "Negative",
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_sales_lead_qualification",
        "description": "Sales: Determine the qualification level of a sales lead based on interaction notes.",
        "arguments": {
          "text": "Company: Acme Corp (250+ employees). Contact expressed interest in enterprise plan, requested pricing information, and scheduled a demo next week. Budget confirmed. Decision timeline: end of quarter.",
          "choices": [
            [
              "Hot Lead"
            ],
            [
              "Warm Lead"
            ],
            [
              "Cold Lead"
            ]
          ]
        },
        "expected_contains": "Hot Lead",
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_support_ticket_priority",
        "description": "IT Support: Assign a priority level to a support ticket based on its description.",
        "arguments": {
          "text": "Unable to access CRM system. Getting error 500 when trying to load customer records. This is affecting sales team productivity but they can still use other systems in the meantime.",
          "choices": [
            [
              "Critical Priority"
            ],
            [
              "High Priority"
            ],
            [
              "Medium Priority"
            ],
            [
              "Low Priority"
            ]
          ]
        },
        "expected_contains": "High Priority",
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_product_feedback_categorization",
        "description": "Product Management: Categorize customer feedback into feedback types.",
        "arguments": {
          "text": "I love the new dashboard layout, but it would be even better if I could customize which widgets appear and their positions on the screen.",
          "choices": [
            [
              "Bug Report"
            ],
            [
              "Feature Request"
            ],
            [
              "UI Feedback"
            ],
            [
              "Performance Issue"
            ],
            [
              "Compliment"
            ]
          ]
        },
        "expected_contains": "Feature Request",
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_document_classification",
        "description": "Legal: Classify a legal document based on its content.",
        "arguments": {
          "text": "This agreement outlines the terms under which Company A will provide consulting services to Company B, including scope of work, deliverables, timeline, and compensation structure.",
          "choices": "NDA, Service Agreement, Employment Contract, License Agreement"
        },
        "expected_contains": "Service Agreement",
        "expected_rows": 1,
        "demo": true
      }
    ],
    "fileId": "3",
    "link": "https://www.boardflare.com/resources/python-functions/text\\ai_choice/ai_choice"
  },
  {
    "name": "ai_extract",
    "description": "Uses AI to extract specific types of information from text.",
    "code": "import requests\nimport json\n\ndef ai_extract(text, extract_type, temperature=0.0, model='mistral-small-latest', max_tokens=1000):\n    \"\"\"\n    Uses AI to extract specific types of information from text.\n    \n    Args:\n        text (str or list): The text to analyze (string or 2D list with a single cell)\n        extract_type (str): Type of information to extract (e.g., 'emails', 'dates', 'action items')\n        temperature (float, optional): Controls response creativity (0-2). Default is 0\n        model (str, optional): ID of the model to use\n        max_tokens (int, optional): Maximum tokens for response generation. Default is 1000\n        \n    Returns:\n        list: 2D list representing the extracted data as a single column\n    \"\"\"\n    # Handle 2D list input (flatten to a single string)\n    if isinstance(text, list):\n        if len(text) > 0 and len(text[0]) > 0:\n            text = str(text[0][0])\n        else:\n            return [[\"Error: Empty input text.\"]]\n    \n    # Using Boardflare API for demo purposes. Replace with any OpenAI compatible API endpoint.\n    api_url = \"https://llm.boardflare.com\" # replace with \"https://api.mistral.ai/v1/chat/completions\"\n    api_key = \"cV4a59t1wjYGs....\" # replace with your Mistral API key\n    \n    # Construct a specific prompt for data extraction\n    extract_prompt = f\"Extract the following from the text: {extract_type}\\n\\nText: {text}\"\n    \n    # Add instruction for structured output\n    extract_prompt += \"\\n\\nReturn ONLY a JSON array of items you extracted. \"\n    extract_prompt += \"Each item should be a single value representing one extracted piece of information. \"\n    extract_prompt += \"Do not include any explanatory text, just the JSON array.\"\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": extract_prompt}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": max_tokens,\n        \"response_format\": {\n            \"type\": \"json_object\",\n        }\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    try:\n        # Make the API request\n        response = requests.post(api_url, headers=headers, json=payload)\n        response.raise_for_status()\n        \n        # Extract the response content\n        response_data = response.json()\n        content = response_data[\"choices\"][0][\"message\"][\"content\"]\n        # print(content)\n        \n        # Extract the JSON array from the response\n        try:\n            # Try to parse the content as JSON directly\n            extracted_data = json.loads(content)\n            \n            # If extracted_data is a dictionary with an \"items\" or \"extracted\" key, use that\n            if isinstance(extracted_data, dict):\n                if \"items\" in extracted_data:\n                    extracted_data = extracted_data[\"items\"]\n                elif \"extracted\" in extracted_data:\n                    extracted_data = extracted_data[\"extracted\"]\n                elif \"results\" in extracted_data:\n                    extracted_data = extracted_data[\"results\"]\n            \n            # Convert the list to a 2D list (single column)\n            if isinstance(extracted_data, list):\n                return [[item] for item in extracted_data]\n            else:\n                return [[\"Error: Unable to parse response. Expected a list.\"]]\n                \n        except (json.JSONDecodeError, ValueError):\n            # If JSON parsing fails, return an error message as a single cell\n            return [[\"Error: Unable to extract data. The AI response wasn't in the expected format.\"]]\n             \n    except requests.exceptions.RequestException as e:\n        # Handle API request errors\n        return [[\"Error: API request failed.\", str(e)]]",
    "test_cases": [
      {
        "id": "test_client_names",
        "description": "Business Development: Extract client names from meeting notes.",
        "arguments": {
          "text": "During today's annual review, we discussed progress with Acme Corporation, Global Enterprises, and TechSolutions Inc. All three clients reported satisfaction with our services.",
          "extract_type": "client names"
        },
        "expected_rows": 3,
        "demo": true
      },
      {
        "id": "test_financial_metrics",
        "description": "Financial Analysis: Extract key financial metrics from a quarterly report.",
        "arguments": {
          "text": "Q1 results exceeded expectations with revenue of $2.4M, an EBITDA margin of 18.5%, and customer acquisition costs decreasing by 12%. Cash reserves stand at $5.2M and our runway extends to 24 months.",
          "extract_type": "financial metrics"
        },
        "expected_rows": 5,
        "demo": true
      },
      {
        "id": "test_action_items",
        "description": "Project Management: Extract action items assigned in an email.",
        "arguments": {
          "text": "Hi team, Following our strategic planning session: 1) Mark needs to finalize the budget by Friday, 2) Sarah will contact vendors for new quotes, 3) Development team must provide timeline estimates by next Wednesday, and 4) Everyone should review the new marketing materials.",
          "extract_type": "action items"
        },
        "expected_rows": 4,
        "demo": true
      },
      {
        "id": "test_contact_information",
        "description": "Contact Management: Extract contact details from scanned business card text.",
        "arguments": {
          "text": "John Smith, Senior Project Manager, Innovative Solutions Inc., jsmith@innovativesolutions.com, +1 (555) 123-4567, 123 Business Avenue, Suite 400, San Francisco, CA 94107",
          "extract_type": "contact information"
        },
        "expected_rows": 6,
        "demo": true
      },
      {
        "id": "test_dates_deadlines",
        "description": "Project Planning: Extract important dates and deadlines from a project update.",
        "arguments": {
          "text": "The initial design phase will be completed by May 15, 2025. The stakeholder review is scheduled for May 20-22, with development starting June 1. Testing will run through September 15, with final delivery expected by October 3, 2025.",
          "extract_type": "dates and deadlines"
        },
        "expected_rows": 5,
        "demo": true
      }
    ],
    "fileId": "4",
    "link": "https://www.boardflare.com/resources/python-functions/text\\ai_extract/ai_extract"
  },
  {
    "name": "ai_fill",
    "description": "Uses AI to fill in missing data in a target range by learning patterns from an example range.",
    "code": "import requests\nimport json\n\ndef ai_fill(example_range, fill_range, temperature=0.0, model='mistral-small-latest', max_tokens=1500):\n    \"\"\"\n    Uses AI to fill in missing data in a target range by learning patterns from an example range.\n    \n    Args:\n        example_range (list): 2D list containing complete data as examples for the AI to learn from\n        fill_range (list): 2D list containing data with missing values to be filled\n        temperature (float, optional): Controls response creativity (0-2). Default is 0\n        model (str, optional): ID of the model to use\n        max_tokens (int, optional): Maximum tokens for response generation. Default is 1500\n        \n    Returns:\n        list: 2D list with missing data filled in\n    \"\"\"\n    # Validate inputs\n    if not isinstance(example_range, list) or not example_range:\n        return [[\"Error: Example range is empty or invalid.\"]]\n    if not isinstance(fill_range, list) or not fill_range:\n        return [[\"Error: Fill range is empty or invalid.\"]]\n    \n    # Using Boardflare API for demo purposes. Replace with any OpenAI compatible API endpoint.\n    api_url = \"https://llm.boardflare.com\" # replace with \"https://api.mistral.ai/v1/chat/completions\"\n    api_key = \"cV4a59t1wjYGs....\" # replace with your Mistral API key\n    \n    # Convert example_range and fill_range to JSON strings for the prompt\n    example_json = json.dumps(example_range)\n    fill_json = json.dumps(fill_range)\n    \n    # Construct a specific prompt for filling data\n    fill_prompt = \"\"\"Fill in the missing values in the target data based on patterns in the example data.\nExample data (complete): {}\\n\\n\nTarget data (with missing values): {}\\n\\n\nStudy the patterns in the example data and complete the target data by filling in missing values. Preserve all existing values in the target data.\"\"\".format(\n        example_json, fill_json\n    )\n    \n    # Add instruction for structured output\n    fill_prompt += \"\\n\\nReturn ONLY a JSON array of arrays (2D array) with the completed target data. \"\n    fill_prompt += \"Do not include any explanatory text, just the JSON array.\"\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": fill_prompt}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": max_tokens,\n        \"response_format\": {\n            \"type\": \"json_object\",\n        }\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    try:\n        # Make the API request\n        response = requests.post(api_url, headers=headers, json=payload)\n        response.raise_for_status()\n        \n        # Extract the response content\n        response_data = response.json()\n        content = response_data[\"choices\"][0][\"message\"][\"content\"]\n        # print(content)\n        \n        # Extract the filled data from the response\n        try:\n            # Try to parse the content as JSON directly\n            filled_data = json.loads(content)\n            \n            # If filled_data is a dictionary with a \"data\" or \"filled_data\" key, use that\n            if isinstance(filled_data, dict):\n                if \"data\" in filled_data:\n                    filled_data = filled_data[\"data\"]\n                elif \"filled_data\" in filled_data:\n                    filled_data = filled_data[\"filled_data\"]\n                elif \"result\" in filled_data:\n                    filled_data = filled_data[\"result\"]\n            \n            # Ensure the filled data is a 2D list\n            if isinstance(filled_data, list) and all(isinstance(row, list) for row in filled_data):\n                # Ensure the dimensions match the original fill_range\n                if (len(filled_data) == len(fill_range) and \n                    all(len(row) == len(fill_range[i]) for i, row in enumerate(filled_data))):\n                    return filled_data\n                else:\n                    return [[\"Error: AI response dimensions don't match the fill range.\"]]\n            else:\n                return [[\"Error: Unable to parse response. Expected a 2D array.\"]]\n                \n        except (json.JSONDecodeError, ValueError):\n            # If JSON parsing fails, return an error message\n            return [[\"Error: Unable to fill data. The AI response wasn't in the expected format.\"]]\n             \n    except requests.exceptions.RequestException as e:\n        # Handle API request errors\n        return [[\"Error: API request failed.\", str(e)]]",
    "test_cases": [
      {
        "id": "test_product_catalog",
        "description": "When filling in missing product specifications in your product catalog based on similar products.",
        "arguments": {
          "example_range": [
            [
              "Product ID",
              "Category",
              "Price",
              "Weight (kg)"
            ],
            [
              "PRD-001",
              "Laptop",
              1299,
              1.8
            ],
            [
              "PRD-002",
              "Laptop",
              999,
              2.1
            ],
            [
              "PRD-003",
              "Tablet",
              499,
              0.7
            ]
          ],
          "fill_range": [
            [
              "Product ID",
              "Category",
              "Price",
              "Weight (kg)"
            ],
            [
              "PRD-004",
              "Laptop",
              null,
              null
            ],
            [
              "PRD-005",
              "Tablet",
              null,
              null
            ],
            [
              "PRD-006",
              null,
              799,
              1.2
            ]
          ]
        },
        "expected_rows": 4,
        "demo": true
      },
      {
        "id": "test_employee_information",
        "description": "When completing missing employee department and location information based on job titles in your HR database.",
        "arguments": {
          "example_range": [
            [
              "Employee ID",
              "Job Title",
              "Department",
              "Location"
            ],
            [
              "EMP-001",
              "Sales Manager",
              "Sales",
              "New York"
            ],
            [
              "EMP-002",
              "Marketing Specialist",
              "Marketing",
              "Chicago"
            ],
            [
              "EMP-003",
              "Sales Representative",
              "Sales",
              "Los Angeles"
            ],
            [
              "EMP-004",
              "Software Developer",
              "Engineering",
              "San Francisco"
            ]
          ],
          "fill_range": [
            [
              "Employee ID",
              "Job Title",
              "Department",
              "Location"
            ],
            [
              "EMP-005",
              "Sales Director",
              null,
              null
            ],
            [
              "EMP-006",
              "UX Designer",
              null,
              null
            ],
            [
              "EMP-007",
              "Marketing Director",
              null,
              null
            ],
            [
              "EMP-008",
              "Senior Developer",
              null,
              null
            ]
          ]
        },
        "expected_rows": 5,
        "demo": true
      },
      {
        "id": "test_financial_forecasts",
        "description": "When completing quarterly financial projections in your budget spreadsheet based on existing data and trends.",
        "arguments": {
          "example_range": [
            [
              "Metric",
              "Q1 2024",
              "Q2 2024",
              "Q3 2024",
              "Q4 2024"
            ],
            [
              "Revenue",
              250000,
              280000,
              310000,
              350000
            ],
            [
              "Expenses",
              180000,
              195000,
              215000,
              235000
            ]
          ],
          "fill_range": [
            [
              "Metric",
              "Q1 2024",
              "Q2 2024",
              "Q3 2024",
              "Q4 2024"
            ],
            [
              "Profit",
              null,
              null,
              null,
              null
            ],
            [
              "Headcount",
              32,
              35,
              null,
              null
            ]
          ]
        },
        "expected_rows": 3,
        "demo": true
      }
    ],
    "fileId": "5",
    "link": "https://www.boardflare.com/resources/python-functions/text\\ai_fill/ai_fill"
  },
  {
    "name": "ai_format",
    "description": "Uses AI to format text according to a specific structure or pattern.",
    "code": "import requests\nimport json\n\ndef ai_format(text, format_instruction, temperature=0.0, model='mistral-small-latest', max_tokens=1500):\n    \"\"\"\n    Uses AI to format text according to a specific structure or pattern.\n    \n    Args:\n        text (str or list): The text to format (string or 2D list with a single cell)\n        format_instruction (str): Instructions describing the desired format\n        temperature (float, optional): Controls response creativity (0-2). Default is 0\n        model (str, optional): ID of the model to use\n        max_tokens (int, optional): Maximum tokens for response generation. Default is 1500\n        \n    Returns:\n        str: The formatted text according to the specified format\n    \"\"\"\n    # Handle 2D list input (flatten to a single string)\n    if isinstance(text, list):\n        if len(text) > 0 and len(text[0]) > 0:\n            text = str(text[0][0])\n        else:\n            return \"Error: Empty input text.\"\n    \n    # Using Boardflare API for demo purposes. Replace with any OpenAI compatible API endpoint.\n    api_url = \"https://llm.boardflare.com\" # replace with \"https://api.mistral.ai/v1/chat/completions\"\n    api_key = \"cV4a59t1wjYGs....\" # replace with your Mistral API key\n    \n    # Construct a specific prompt for formatting\n    format_prompt = f\"Format the following text according to this format instruction: {format_instruction}\\n\\nText to format: {text}\"\n    \n    # Remove JSON object instructions, just ask for plain formatted text\n    format_prompt += \"\\n\\nReturn ONLY the formatted text. Do not include any explanatory text, just the formatted result.\"\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": format_prompt}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": max_tokens\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    try:\n        # Make the API request\n        response = requests.post(api_url, headers=headers, json=payload)\n        response.raise_for_status()\n        \n        # Extract the response content\n        response_data = response.json()\n        content = response_data[\"choices\"][0][\"message\"][\"content\"]\n        \n        # Return the plain formatted text\n        return content.strip()\n        \n    except requests.exceptions.RequestException as e:\n        # Handle API request errors\n        return f\"Error: API request failed. {str(e)}\"",
    "test_cases": [
      {
        "id": "test_customer_contact_info",
        "description": "Standardizing customer contact information into a professional format.",
        "arguments": {
          "text": "John Smith / Marketing Director - Acme Inc / jsmith@acme.co - 555.123.4567",
          "format_instruction": "standard business contact card format"
        },
        "expected_contains_any": [
          "John Smith",
          "Marketing Director",
          "Acme Inc",
          "jsmith@acme.co",
          "555"
        ],
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_financial_figures",
        "description": "Standardizing financial figures for reporting.",
        "arguments": {
          "text": "Revenue: 2.4m; COGS: 1.1m; Gross Margin: 1.3m (54%); Opex: 950k; EBITDA: 350k",
          "format_instruction": "professional financial statement format with proper currency notation"
        },
        "expected_contains_any": [
          "Revenue",
          "2,400,000",
          "Cost of Goods Sold",
          "1,100,000",
          "Gross Margin",
          "Operating Expenses",
          "EBITDA"
        ],
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_customer_feedback",
        "description": "Converting free-form customer feedback into a structured review format.",
        "arguments": {
          "text": "Used the product for 3 weeks. Good quality but shipping took forever. Customer service was helpful though. Probably would buy again if they fix delivery issues.",
          "format_instruction": "structured product review with ratings"
        },
        "expected_contains_any": [
          "Rating",
          "Product Quality",
          "Shipping",
          "Customer Service",
          "Would Purchase Again"
        ],
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_address_data",
        "description": "Standardizing inconsistent address entries into a standard format.",
        "arguments": {
          "text": "123 business park dr suite 12, austin tx 78701",
          "format_instruction": "standard US business address format"
        },
        "expected_contains_any": [
          "123 Business Park Drive",
          "Suite 12",
          "Austin",
          "TX",
          "78701"
        ],
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_meeting_notes",
        "description": "Converting meeting notes to a structured action item list.",
        "arguments": {
          "text": "Tom said we need to finish the report by Friday. Maria will contact the client about budget concerns. Everyone should review the new marketing strategy before next meeting on 5/10.",
          "format_instruction": "action items with responsible parties and deadlines"
        },
        "expected_contains_any": [
          "ACTION ITEM",
          "Tom",
          "Friday",
          "Maria",
          "client",
          "budget",
          "May 10"
        ],
        "expected_rows": 1,
        "demo": true
      }
    ],
    "fileId": "6",
    "link": "https://www.boardflare.com/resources/python-functions/text\\ai_format/ai_format"
  },
  {
    "name": "ai_list",
    "description": "Uses AI to generate a list of items based on the prompt and optional values data.",
    "code": "import requests\nimport json\n\ndef ai_list(prompt, values=None, temperature=0.0, model='mistral-small-latest', max_tokens=1000):\n    \"\"\"\n    Uses AI to generate a list of items based on the prompt and optional values data.\n    \n    Args:\n        prompt (str): Instruction for AI to create a list\n        values (list, optional): 2D list containing additional data to append to prompt\n        temperature (float, optional): Controls response creativity (0-2). Default is 0\n        model (str, optional): ID of the model to use\n        max_tokens (int, optional): Maximum tokens for response generation. Default is 1000\n        \n    Returns:\n        list: 2D list representing the generated list data as a single column\n    \"\"\"\n    # Using Boardflare API for demo purposes. Replace with any OpenAI compatible API endpoint.\n    api_url = \"https://llm.boardflare.com\" # replace with \"https://api.mistral.ai/v1/chat/completions\"\n    api_key = \"cV4a59t1wjYGs....\" # replace with your Mistral API key\n    \n    # Construct a specific prompt for list generation\n    list_prompt = f\"Generate a list based on this request: {prompt}\"\n    \n    # Add values information if provided\n    if values is not None:\n        values_str = \"\\n\".join([str(item[0]) for item in values]) if len(values) > 0 and len(values[0]) > 0 else \"\"\n        if values_str:\n            list_prompt += f\"\\n\\nUse this information to help create the list:\\n{values_str}\"\n    \n    # Add instruction for structured output\n    list_prompt += \"\\nReturn ONLY a JSON array of items for the list. \"\n    list_prompt += \"Each item should be a single value. \"\n    list_prompt += \"Do not include any explanatory text, just the JSON array.\"\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": list_prompt}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": max_tokens,\n        \"response_format\": {\n            \"type\": \"json_object\",\n        }\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    try:\n        # Make the API request\n        response = requests.post(api_url, headers=headers, json=payload)\n        response.raise_for_status()\n        \n        # Extract the response content\n        response_data = response.json()\n        content = response_data[\"choices\"][0][\"message\"][\"content\"]\n        \n        # Extract the JSON array from the response\n        try:\n            # Try to parse the content as JSON directly\n            list_data = json.loads(content)\n            \n            # If list_data is a dictionary with an \"items\" or \"list\" key, use that\n            if isinstance(list_data, dict):\n                if \"items\" in list_data:\n                    list_data = list_data[\"items\"]\n                elif \"list\" in list_data:\n                    list_data = list_data[\"list\"]\n                else:\n                    # Check for any array key in the response\n                    for key, value in list_data.items():\n                        if isinstance(value, list):\n                            list_data = value\n                            break\n            \n            # Convert the list to a 2D list (single column)\n            if isinstance(list_data, list):\n                # Ensure each item is a string and properly formatted as a single-item list\n                result = []\n                for item in list_data:\n                    if isinstance(item, list):\n                        # If item is already a list, ensure it has exactly one element\n                        if len(item) >= 1:\n                            result.append([str(item[0])])\n                        else:\n                            result.append([\"\"])\n                    else:\n                        # If item is not a list, make it a single-item list\n                        result.append([str(item)])\n                return result\n            else:\n                return [[\"Error: Unable to parse response. Expected a list.\"]]\n                \n        except (json.JSONDecodeError, ValueError):\n            # If JSON parsing fails, return an error message as a single cell\n            return [[\"Error: Unable to generate list. The AI response wasn't in the expected format.\"]]\n             \n    except requests.exceptions.RequestException as e:\n        # Handle API request errors\n        return [[\"Error: API request failed.\", str(e)]]",
    "test_cases": [
      {
        "id": "test_marketing_kpis",
        "description": "Generate a list of KPIs relevant to a marketing department.",
        "arguments": {
          "prompt": "List 4 essential marketing KPIs for quarterly performance reviews"
        },
        "expected_rows": 4,
        "demo": true
      },
      {
        "id": "test_risk_mitigation_strategies",
        "description": "Generate a list of risk mitigation strategies for a business project.",
        "arguments": {
          "prompt": "List 4 effective risk mitigation strategies for enterprise software implementation"
        },
        "expected_rows": 4,
        "demo": true
      },
      {
        "id": "test_compliance_requirements",
        "description": "Get a list of compliance requirements for a specific industry.",
        "arguments": {
          "prompt": "List 4 key compliance requirements for healthcare organizations"
        },
        "expected_rows": 4,
        "demo": true
      },
      {
        "id": "test_action_items_from_values",
        "description": "Generate a list of action items based on specific meeting notes provided as values.",
        "arguments": {
          "prompt": "List 4 priority action items based on these quarterly business review notes:",
          "values": [
            [
              "Q1 revenue fell 5% below target"
            ],
            [
              "Customer complaints increased by 12%"
            ],
            [
              "New product launch delayed by 3 weeks"
            ]
          ]
        },
        "expected_rows": 4,
        "demo": true
      },
      {
        "id": "test_smart_goals",
        "description": "Generate a list of SMART goals for a specific department.",
        "arguments": {
          "prompt": "List 4 SMART goals for an HR department focused on improving employee retention"
        },
        "expected_rows": 4,
        "demo": true
      }
    ],
    "fileId": "7",
    "link": "https://www.boardflare.com/resources/python-functions/text\\ai_list/ai_list"
  },
  {
    "name": "ai_table",
    "description": "Uses AI to generate a structured table based on the prompt and optional header/source data.",
    "code": "import requests\nimport json\n\ndef ai_table(prompt, header=None, source=None, temperature=0.0, model='mistral-small-latest', max_tokens=1500):\n    \"\"\"\n    Uses AI to generate a structured table based on the prompt and optional header/source data.\n    \n    Args:\n        prompt (str): Instruction for AI to create a table\n        header (list, optional): 2D list containing table header (column names)\n        source (list, optional): 2D list containing source data used to create the table\n        temperature (float, optional): Controls response creativity (0-2). Default is 0\n        model (str, optional): ID of the model to use\n        max_tokens (int, optional): Maximum tokens for response generation. Default is 1500\n        \n    Returns:\n        list: 2D list representing the generated table data\n    \"\"\"\n    # Using Boardflare API for demo purposes. Replace with any OpenAI compatible API endpoint.\n    api_url = \"https://llm.boardflare.com\" # replace with \"https://api.mistral.ai/v1/chat/completions\"\n    api_key = \"cV4a59t1wjYGs....\" # replace with your Mistral API key\n    \n    # Construct a specific prompt for table generation\n    table_prompt = f\"Generate a well-organized table based on this request: {prompt}\"\n    \n    # Add header information if provided\n    if header is not None:\n        # Assuming header is a 2D list with a single row for column names\n        if header and len(header) > 0:\n            header_str = \", \".join(str(col) for col in header[0])\n            table_prompt += f\"\\nUse exactly these columns: {header_str}\"\n    \n    # Add source data information if provided\n    if source is not None:\n        source_str = json.dumps(source, indent=2)\n        table_prompt += f\"\\n\\nUse this source data to create the table:\\n{source_str}\"\n    \n    # Add instruction for structured output\n    table_prompt += \"\\nReturn ONLY a JSON array of arrays (2D array) with the table data. \"\n    table_prompt += \"The first row should contain column headers if not provided. \"\n    table_prompt += \"Each subsequent row should contain data that fits the columns. \"\n    table_prompt += \"Do not include any explanatory text, just the JSON array.\"\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": table_prompt}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": max_tokens,\n        \"response_format\": {\n            \"type\": \"json_object\",\n        }\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    try:\n        # Make the API request\n        response = requests.post(api_url, headers=headers, json=payload)\n        response.raise_for_status()\n        \n        # Extract the response content\n        response_data = response.json()\n        content = response_data[\"choices\"][0][\"message\"][\"content\"]\n        \n        # Extract the JSON array from the response\n        try:\n            # Try to parse the content as JSON directly\n            table_data = json.loads(content)\n            return table_data\n        except (json.JSONDecodeError, ValueError):\n            # If JSON parsing fails, return an error message as a single cell\n            return [[\"Error: Unable to generate table. The AI response wasn't in the expected format.\"]]\n             \n    except Exception as e:\n        # Handle any exception, including API request errors\n        return [[\"Error: API request failed.\", str(e)]]",
    "test_cases": [
      {
        "id": "test_smartphone_features",
        "description": "Generate a table listing features of different smartphones for product comparison",
        "arguments": {
          "prompt": "Create a table listing the features of different smartphones including brand, model, camera quality, battery life."
        },
        "expected_contains_any": [
          "Brand",
          "Model",
          "Camera",
          "Battery"
        ],
        "expected_rows": 5,
        "demo": true
      },
      {
        "id": "test_tourist_destinations_with_header",
        "description": "Create a reference table of top tourist destinations using a predefined header format",
        "arguments": {
          "prompt": "Generate a table of top 5 tourist destinations.",
          "header": [
            [
              "Country",
              "Popular Attractions",
              "Best Time to Visit",
              "Average Cost"
            ]
          ]
        },
        "expected_contains_any": [
          "Country",
          "Popular Attractions",
          "Best Time to Visit",
          "Average Cost"
        ],
        "expected_rows": 6,
        "demo": true
      },
      {
        "id": "test_sales_summary_with_source",
        "description": "Summarize sales data by product category for quarterly business review",
        "arguments": {
          "prompt": "Summarize the sales data by product category.",
          "source": [
            [
              "Product",
              "Category",
              "Sales Amount"
            ],
            [
              "Laptop",
              "Tech",
              1200
            ],
            [
              "Mouse",
              "Tech",
              25
            ],
            [
              "Keyboard",
              "Tech",
              75
            ],
            [
              "T-Shirt",
              "Apparel",
              20
            ],
            [
              "Jeans",
              "Apparel",
              50
            ],
            [
              "Laptop",
              "Tech",
              1350
            ],
            [
              "Hoodie",
              "Apparel",
              45
            ]
          ]
        },
        "expected_contains_any": [
          "Category",
          "Tech",
          "Apparel"
        ],
        "expected_rows": 3,
        "demo": true
      }
    ],
    "fileId": "8",
    "link": "https://www.boardflare.com/resources/python-functions/text\\ai_table/ai_table"
  },
  {
    "name": "internet_csv",
    "description": "Fetches a CSV file from the internet (with CORS proxy) and returns its contents as a 2D list.",
    "code": "import csv\nimport io\nimport requests\n\n\ndef internet_csv(url):\n    \"\"\"\n    Fetches a CSV file from the internet (with CORS proxy) and returns its contents as a 2D list.\n\n    Args:\n        url (str): The direct URL to the CSV file.\n\n    Returns:\n        list[list[str]]: 2D list representing the CSV contents, where each sublist is a row.\n\n    Raises:\n        ValueError: If the URL is invalid or the content cannot be parsed as CSV.\n    \"\"\"\n    if not isinstance(url, str) or not url.strip():\n        raise ValueError(\"A non-empty URL string must be provided.\")\n\n    cors_url = f\"https://cors.boardflare.com/{url}\"\n    try:\n        response = requests.get(cors_url)\n        response.raise_for_status()\n        content = response.text\n        reader = csv.reader(io.StringIO(content))\n        data = [row for row in reader]\n        if not data:\n            raise ValueError(\"CSV file is empty or could not be parsed.\")\n        return data\n    except Exception as e:\n        raise ValueError(f\"Failed to fetch or parse CSV: {e}\")\n",
    "test_cases": [
      {
        "id": "zillow_market_heat_index",
        "description": "Import the Zillow Market Heat Index for major US metro areas as a range in Excel.",
        "arguments": {
          "url": "https://files.zillowstatic.com/research/public_csvs/market_temp_index/Metro_market_temp_index_uc_sfrcondo_month.csv?t=1746621339"
        },
        "expected_type": "list",
        "expected_rows": 5,
        "demo": true
      }
    ],
    "fileId": "9",
    "link": "https://www.boardflare.com/resources/python-functions/text\\internet_csv/internet_csv"
  },
  {
    "name": "onedrive_csv",
    "description": "Loads a CSV file from OneDrive using the global graphToken variable and returns its contents as a 2D list.",
    "code": "import requests\nimport csv\nimport io\nimport pandas as pd\n\ndef onedrive_csv(file_path):\n    \"\"\"\n    Loads a CSV file from OneDrive using the global graphToken variable and returns its contents as a 2D list.\n\n    Args:\n        file_path (str): The path to the CSV file in the user's OneDrive (e.g., '/Documents/data.csv').\n\n    Returns:\n        list: 2D list representing the CSV file's contents.\n\n    Raises:\n        Exception: If the file cannot be retrieved or parsed.\n    \"\"\"\n    # Use global graphToken if available\n    token = None\n    try:\n        token = globals()[\"graphToken\"]\n    except KeyError:\n        token = None\n    if not token:\n        raise Exception(\"Microsoft Graph token is not set. Please click login button next to OneDrive in Functions tab.\")\n    if not file_path or not isinstance(file_path, str):\n        raise Exception(\"A valid file_path string must be provided.\")\n\n    url = f\"https://graph.microsoft.com/v1.0/me/drive/root:{file_path}:/content\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Accept\": \"text/csv\"\n    }\n    response = requests.get(url, headers=headers)\n    if response.status_code != 200:\n        raise Exception(f\"Failed to retrieve file: {response.status_code} {response.text}\")\n\n    csv_content = response.content.decode('utf-8')\n    # You could also use pandas to read the CSV content into a DataFrame\n    df = pd.read_csv(io.StringIO(csv_content))\n    print(df.head())\n\n    # For demo puposes, we will convert the CSV content to a 2D list\n    reader = csv.reader(io.StringIO(csv_content))\n    table = [row for row in reader]\n    return table\n",
    "test_cases": [
      {
        "id": "demo_load_csv_onedrive",
        "description": "Demo: Load a CSV file from OneDrive using the file path '/Documents/data.csv'.",
        "arguments": {
          "file_path": "/Documents/data.csv"
        },
        "expect_error": false,
        "expected_rows": 5,
        "demo": true
      }
    ],
    "fileId": "10",
    "link": "https://www.boardflare.com/resources/python-functions/text\\onedrive_csv/onedrive_csv"
  },
  {
    "name": "text_distance",
    "description": "Calculate text similarity scores between needle(s) and haystack items.",
    "code": "import textdistance\n\ndef text_distance(needle, haystack, algorithm='jaccard', top_n=1):\n    \"\"\"Calculate text similarity scores between needle(s) and haystack items.\n    \n    Args:\n        needle: String or 2D list of strings to search for\n        haystack: 2D list of strings to search within\n        algorithm (str): Algorithm name from textdistance library (default: 'jaccard')\n        top_n (int): Number of top matches to return (default: 1).\n    \n    Returns:\n        list: For each needle, a flat list of [position, score, position, score, ...] for the top N matches (row format).\n    \"\"\"\n    algo_func = getattr(textdistance, algorithm)\n\n    # Handle needle as either string or 2D list\n    if isinstance(needle, str):\n        needle_flat = [needle] if needle.strip() else []\n    else:\n        # Flatten 2D lists and filter out None values\n        needle_flat = [item for sublist in needle for item in sublist if item is not None]\n\n    haystack_flat = [item for sublist in haystack for item in sublist if item is not None]\n\n    if not haystack_flat:\n        return [[] for _ in needle_flat] if needle_flat else []\n\n    results = []\n    for needle_item in needle_flat:\n        if not str(needle_item).strip():\n            results.append([])\n            continue\n        scores = [(index + 1, round(algo_func.normalized_similarity(str(needle_item), str(item)), 2))\n                  for index, item in enumerate(haystack_flat)]\n        scores.sort(key=lambda x: x[1], reverse=True)\n        # Flatten the top matches into a single row\n        row = []\n        for score in scores[:top_n]:\n            row.extend(list(score))  # [position, score, ...]\n        results.append(row)\n\n    # If only one needle, return just the row for that needle\n    if len(results) == 1:\n        return results[0]\n    return results",
    "test_cases": [
      {
        "id": "test_exact_match",
        "description": "Find products with names similar to 'apple' in your product catalog.",
        "arguments": {
          "needle": [
            [
              "apple"
            ]
          ],
          "haystack": [
            [
              "appl"
            ],
            [
              "banana"
            ],
            [
              "orange"
            ],
            [
              "grape"
            ]
          ],
          "algorithm": "jaccard",
          "top_n": 1
        },
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_customer_names",
        "description": "Find customers with names similar to 'Johnson' in your customer database.",
        "arguments": {
          "needle": "Johnson",
          "haystack": [
            [
              "Johnsen"
            ],
            [
              "Jonson"
            ],
            [
              "Johanson"
            ],
            [
              "Smith"
            ],
            [
              "Jonsen"
            ]
          ],
          "algorithm": "jaro_winkler",
          "top_n": 3
        },
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_multiple_products",
        "description": "Find matches for multiple product names using Levenshtein distance.",
        "arguments": {
          "needle": [
            [
              "aple",
              "banaa"
            ]
          ],
          "haystack": [
            [
              "apple"
            ],
            [
              "banana"
            ],
            [
              "orange"
            ],
            [
              "grape"
            ]
          ],
          "algorithm": "levenshtein",
          "top_n": 2
        },
        "expected_rows": 2,
        "demo": true
      },
      {
        "id": "test_address_fuzzy_matching",
        "description": "Match addresses in your CRM with addresses in your billing system.",
        "arguments": {
          "needle": [
            [
              "123 Main St"
            ],
            [
              "456 Oak Ave"
            ]
          ],
          "haystack": [
            [
              "123 Main Street"
            ],
            [
              "456 Oak Avenue"
            ],
            [
              "789 Pine Blvd"
            ],
            [
              "321 Elm Street"
            ]
          ],
          "algorithm": "ratcliff_obershelp",
          "top_n": 1
        },
        "expected_rows": 2,
        "demo": true
      }
    ],
    "fileId": "11",
    "link": "https://www.boardflare.com/resources/python-functions/text\\text_distance/text_distance"
  },
  {
    "name": "vader_sentiment",
    "description": "Analyzes sentiment of text using VADER.",
    "code": "import nltk\nfrom nltk.sentiment import SentimentIntensityAnalyzer\n\n# Ensure you have downloaded the necessary NLTK data\nnltk.download('vader_lexicon')\n\ndef vader_sentiment(text):\n    \"\"\"Analyzes sentiment of text using VADER.\n    Args:\n        text (str): Text to analyze\n    Returns:\n        float: Compound sentiment score (-1 to 1)\n    \"\"\"\n    if not isinstance(text, str):\n        return 0.0 # Return neutral for non-string input\n    sia = SentimentIntensityAnalyzer()\n    sentiment = sia.polarity_scores(text)\n    return round(sentiment['compound'], 4) # Round for consistency",
    "test_cases": [
      {
        "id": "test_positive_review",
        "description": "Analyze the sentiment of a positive product review.",
        "arguments": {
          "text": "I absolutely love this product! It exceeded all my expectations and I would highly recommend it to anyone."
        },
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_negative_feedback",
        "description": "Analyze the sentiment of negative customer feedback.",
        "arguments": {
          "text": "The customer service was terrible. I waited for hours and my issue was never resolved properly."
        },
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_neutral_statement",
        "description": "Analyze the sentiment of a neutral business statement.",
        "arguments": {
          "text": "Our company will be conducting the annual inventory count on June 15th. All departments will participate as scheduled."
        },
        "expected_rows": 1,
        "demo": true
      },
      {
        "id": "test_mixed_sentiment",
        "description": "Analyze text with mixed positive and negative elements.",
        "arguments": {
          "text": "While the product quality is excellent, the shipping was delayed which was disappointing."
        },
        "expected_rows": 1,
        "demo": true
      }
    ],
    "fileId": "12",
    "link": "https://www.boardflare.com/resources/python-functions/text\\vader_sentiment/vader_sentiment"
  },
  {
    "name": "web_content",
    "description": "Returns web page content in markdown format using Jina.  Useful as a starting point for extraction, summarization, etc.",
    "code": "import requests\n\ndef web_content(url):\n    \"\"\"\n    Returns web page content in markdown format using Jina.  Useful as a starting point for extraction, summarization, etc.\n\n    Args:\n        url (str): The full URL to fetch.\n\n    Returns:\n        str: The content of the response from the URL.\n    \"\"\"\n    headers = {\n        \"X-Retain-Images\": \"none\"\n    }\n    base_url = \"https://r.jina.ai/\"\n    full_url = base_url + url\n    response = requests.get(full_url, headers=headers)\n    response.raise_for_status()\n    # Extract content after 'Markdown Content:' marker\n    try:\n        content = response.text.split(\"Markdown Content:\")[1]\n    except IndexError:\n        # Handle cases where the marker might not be present\n        content = response.text \n    return content.strip() # Strip leading/trailing whitespace",
    "test_cases": [
      {
        "id": "test_company_page_content",
        "description": "Extract content from a company page to analyze their business model.",
        "arguments": {
          "url": "https://www.ycombinator.com/companies/airbnb"
        },
        "expected_contains_any": [
          "Airbnb",
          "accommodation",
          "travel"
        ],
        "expected_rows": 1,
        "demo": true
      }
    ],
    "fileId": "13",
    "link": "https://www.boardflare.com/resources/python-functions/text\\web_content/web_content"
  },
  {
    "name": "zillow",
    "description": "Searches for real estate property information from Zillow using the pyzill library functionality.",
    "code": "import requests\nimport json\nimport re\nfrom urllib.parse import urlparse\n\ndef zillow(search_location, property_type=\"all\", min_price=None, max_price=None, \n           min_beds=None, max_beds=None, min_baths=None, max_baths=None, limit=10, \n           property_id=None, property_url=None, search_type=\"for_sale\", \n           ne_lat=None, ne_long=None, sw_lat=None, sw_long=None, zoom_value=10):\n    \"\"\"\n    Searches for real estate property information from Zillow using the pyzill library functionality.\n    \n    Args:\n        search_location (str): Location to search for properties (city, zip code, or neighborhood)\n        property_type (str, optional): Type of property to search for (\"house\", \"apartment\", \"condo\", \"townhome\", or \"all\"). Defaults to \"all\".\n        min_price (int, optional): Minimum price in dollars. Defaults to None.\n        max_price (int, optional): Maximum price in dollars. Defaults to None.\n        min_beds (int, optional): Minimum number of bedrooms. Defaults to None.\n        max_beds (int, optional): Maximum number of bedrooms. Defaults to None.\n        min_baths (int, optional): Minimum number of bathrooms. Defaults to None.\n        max_baths (int, optional): Maximum number of bathrooms. Defaults to None.\n        limit (int, optional): Maximum number of properties to return. Defaults to 10.\n        property_id (str, optional): Specific Zillow property ID to look up. Defaults to None.\n        property_url (str, optional): Specific Zillow property URL to look up. Defaults to None.\n        search_type (str, optional): Type of search: \"for_sale\", \"for_rent\", or \"sold\". Defaults to \"for_sale\".\n        ne_lat (float, optional): Northeast latitude coordinate for map bounds. Defaults to None.\n        ne_long (float, optional): Northeast longitude coordinate for map bounds. Defaults to None.\n        sw_lat (float, optional): Southwest latitude coordinate for map bounds. Defaults to None.\n        sw_long (float, optional): Southwest longitude coordinate for map bounds. Defaults to None.\n        zoom_value (int, optional): Zoom level for the map search (1-20). Defaults to 10.\n    \n    Returns:\n        list: 2D list containing property information. Each row represents a property with columns for \n              address, price, bedrooms, bathrooms, square footage, property type, Zillow URL, \n              year built, lot size, and days on market\n    \"\"\"\n    def send_request_through_proxy(target_url):\n        \"\"\"\n        Sends a request to Zillow through proxy using Bright Data API format.\n        \n        Args:\n            target_url (str): Target URL to fetch\n            \n        Returns:\n            requests.Response: Response from the server\n        \"\"\"\n        body = {\n            \"zone\": \"datacenter_proxy1\",\n            \"url\": target_url,\n            \"format\": \"raw\",\n            \"method\": \"GET\"\n        }\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Referer\": \"https://www.zillow.com/\",\n            \"Cache-Control\": \"no-cache\"\n        }\n        response = requests.post(\n            url=\"https://ip_proxy.boardflare.com/\",\n            headers=headers,\n            data=json.dumps(body)\n        )\n        return response\n\n    def get_property_by_id(property_id):\n        \"\"\"\n        Gets property details by Zillow property ID\n        \n        Args:\n            property_id (str): Zillow property ID\n            \n        Returns:\n            dict: Property data\n        \"\"\"\n        # Determine if it's a home ID (numeric) or department ID (alphanumeric)\n        is_home_id = property_id.isdigit()\n        \n        # Construct URL based on ID type\n        if is_home_id:\n            url = f\"https://www.zillow.com/graphql/?zpid={property_id}&contactFormRenderParameter=&queryId=6536f1e817fcf99dcb31e36e1c4a9d1c\"\n        else:\n            url = f\"https://www.zillow.com/graphql/?propertyId={property_id}&contactFormRenderParameter=&queryId=9e73b548e0cfb0f0dfb02f85f91e383e\"\n        \n        response = send_request_through_proxy(url)\n        response.raise_for_status()\n        data = response.json()\n        \n        return data\n\n    def get_property_by_url(property_url):\n        \"\"\"\n        Gets property details by Zillow property URL\n        \n        Args:\n            property_url (str): Zillow property URL\n            \n        Returns:\n            dict: Property data\n        \"\"\"\n        # Extract property ID from URL\n        parsed_url = urlparse(property_url)\n        path = parsed_url.path\n        \n        # Try to detect the type of URL and extract the ID\n        if \"homedetails\" in path:\n            # Format: /homedetails/123-Main-St-City-ST-12345/12345_zpid/\n            match = re.search(r'(\\d+)_zpid', path)\n            if match:\n                property_id = match.group(1)\n                return get_property_by_id(property_id)\n        elif \"apartments\" in path:\n            # Format: /apartments/city-st/property-name/ID/\n            segments = path.strip('/').split('/')\n            if len(segments) >= 4:\n                property_id = segments[-1]\n                return get_property_by_id(property_id)\n        \n        # If we can't parse the ID, try to fetch the page and extract data\n        response = send_request_through_proxy(property_url)\n        response.raise_for_status()\n        html_content = response.text\n        \n        # Extract the property data from the HTML\n        # Look for the data in the window.__PRELOADED_STATE__ variable\n        match = re.search(r'window\\.__PRELOADED_STATE__\\s*=\\s*({.*?});', html_content, re.DOTALL)\n        if match:\n            json_str = match.group(1)\n            try:\n                data = json.loads(json_str)\n                return data\n            except json.JSONDecodeError:\n                pass\n                \n        # If not found, try to extract from hdpApolloPreloadedData\n        match = re.search(r'<script data-zrr-shared-data-key=\"hdpApolloPreloadedData\" type=\"application/json\">(.*?)</script>', html_content, re.DOTALL)\n        if match:\n            json_str = match.group(1).replace('&quot;', '\"')\n            try:\n                data = json.loads(json_str)\n                return data\n            except json.JSONDecodeError:\n                pass\n        \n        return None\n\n    def search_properties(search_type, search_value, property_type, \n                       min_beds, max_beds, min_baths, max_baths, \n                       min_price, max_price, ne_lat, ne_long, \n                       sw_lat, sw_long, zoom_value, limit):\n        \"\"\"\n        Searches for properties based on various criteria\n        \n        Args:\n            search_type (str): \"for_sale\", \"for_rent\", or \"sold\"\n            search_value (str): Text search query\n            property_type (str): Type of property\n            min_beds (int): Minimum bedrooms\n            max_beds (int): Maximum bedrooms\n            min_baths (float): Minimum bathrooms\n            max_baths (float): Maximum bathrooms\n            min_price (int): Minimum price\n            max_price (int): Maximum price\n            ne_lat (float): Northeast latitude\n            ne_long (float): Northeast longitude\n            sw_lat (float): Southwest latitude\n            sw_long (float): Southwest longitude\n            zoom_value (int): Map zoom level\n            limit (int): Maximum number of results\n            \n        Returns:\n            list: List of property data\n        \"\"\"\n        # Build filter state according to property type\n        filter_state = build_filter_state(property_type, min_price, max_price, min_beds, max_beds, min_baths, max_baths)\n        \n        # Build URL for search type\n        base_url = \"https://www.zillow.com/search/GetSearchPageState.htm\"\n        \n        # Prepare the search query parameters\n        params = {\n            \"searchQueryState\": json.dumps({\n                \"pagination\": {},\n                \"usersSearchTerm\": search_value,\n                \"mapBounds\": {\n                    \"west\": sw_long,\n                    \"east\": ne_long,\n                    \"south\": sw_lat,\n                    \"north\": ne_lat\n                },\n                \"mapZoom\": zoom_value,\n                \"isMapVisible\": True,\n                \"filterState\": filter_state,\n                \"isListVisible\": True,\n                \"category\": \"cat1\" if search_type == \"for_sale\" else (\"cat2\" if search_type == \"for_rent\" else \"cat3\")\n            }),\n            \"wants\": json.dumps({\"cat1\": [\"listResults\", \"mapResults\"], \"cat2\": [\"listResults\", \"mapResults\"], \"cat3\": [\"listResults\", \"mapResults\"]}),\n            \"requestId\": 1\n        }\n        \n        # Build full URL with parameters for the proxy\n        full_url = f\"{base_url}?{urlencode(params)}\"\n        \n        # Make request through proxy\n        response = send_request_through_proxy(full_url)\n        response.raise_for_status()\n        search_data = response.json()\n        \n        # Process results based on search type\n        cat_key = \"cat1\" if search_type == \"for_sale\" else (\"cat2\" if search_type == \"for_rent\" else \"cat3\")\n        \n        properties = []\n        \n        # Get map results\n        if \"searchResults\" in search_data and \"mapResults\" in search_data[\"searchResults\"]:\n            map_results = search_data[\"searchResults\"][\"mapResults\"]\n            \n            for i, property_data in enumerate(map_results):\n                if i >= limit:\n                    break\n                properties.append(format_property_data(property_data))\n                    \n        # Get list results if map results are not available\n        elif cat_key in search_data and \"searchResults\" in search_data[cat_key] and \"listResults\" in search_data[cat_key][\"searchResults\"]:\n            list_results = search_data[cat_key][\"searchResults\"][\"listResults\"]\n            \n            for i, property_data in enumerate(list_results):\n                if i >= limit:\n                    break\n                properties.append(format_property_data(property_data))\n        \n        return properties\n\n    def format_property_data(property_data):\n        \"\"\"\n        Formats property data into a consistent format\n        \n        Args:\n            property_data (dict): Property data from Zillow API\n            \n        Returns:\n            list: Formatted property data\n        \"\"\"\n        # Extract property details from the data structure, handling different data formats\n        # This function needs to be flexible as Zillow's data structure varies between APIs\n        \n        # For search results format\n        if isinstance(property_data, dict) and \"address\" in property_data:\n            address = property_data.get(\"address\", \"N/A\")\n            price = property_data.get(\"price\", \"N/A\")\n            beds = property_data.get(\"beds\", property_data.get(\"bedrooms\", \"N/A\"))\n            baths = property_data.get(\"baths\", property_data.get(\"bathrooms\", \"N/A\"))\n            area = property_data.get(\"area\", property_data.get(\"livingArea\", \"N/A\"))\n            prop_type = property_data.get(\"statusType\", property_data.get(\"homeType\", \"N/A\"))\n            \n            # Build URL\n            if \"detailUrl\" in property_data:\n                url = \"https://www.zillow.com\" + property_data.get(\"detailUrl\", \"\")\n            elif \"zpid\" in property_data:\n                url = f\"https://www.zillow.com/homedetails/{property_data['zpid']}_zpid/\"\n            else:\n                url = \"N/A\"\n                \n            year_built = property_data.get(\"yearBuilt\", \"N/A\")\n            lot_size = property_data.get(\"lotSize\", property_data.get(\"lotAreaValue\", \"N/A\"))\n            days_on_market = property_data.get(\"daysOnZillow\", property_data.get(\"daysOnMarket\", \"N/A\"))\n            \n            return [\n                address, price, beds, baths, area, prop_type, \n                url, year_built, lot_size, days_on_market\n            ]\n        \n        # For property details API format\n        elif isinstance(property_data, dict) and \"data\" in property_data and \"property\" in property_data[\"data\"]:\n            prop = property_data[\"data\"][\"property\"]\n            \n            address = prop.get(\"address\", {}).get(\"streetAddress\", \"N/A\")\n            if \"city\" in prop.get(\"address\", {}):\n                address += f\", {prop['address']['city']}, {prop['address'].get('state', '')}\"\n                \n            price = prop.get(\"price\", prop.get(\"priceForHDP\", \"N/A\"))\n            if isinstance(price, (int, float)):\n                price = f\"${price:,}\"\n                \n            beds = prop.get(\"bedrooms\", prop.get(\"beds\", \"N/A\"))\n            baths = prop.get(\"bathrooms\", prop.get(\"baths\", \"N/A\"))\n            \n            if \"livingAreaValue\" in prop:\n                area = f\"{prop['livingAreaValue']} {prop.get('livingAreaUnits', 'sqft')}\"\n            else:\n                area = \"N/A\"\n                \n            prop_type = prop.get(\"homeType\", \"N/A\")\n            url = f\"https://www.zillow.com/homedetails/{prop.get('zpid', '')}_zpid/\"\n            year_built = prop.get(\"yearBuilt\", \"N/A\")\n            \n            if \"lotAreaValue\" in prop:\n                lot_size = f\"{prop['lotAreaValue']} {prop.get('lotAreaUnits', 'acres')}\"\n            else:\n                lot_size = \"N/A\"\n                \n            days_on_market = prop.get(\"daysOnZillow\", prop.get(\"timeOnZillow\", \"N/A\"))\n            \n            return [\n                address, price, beds, baths, area, prop_type, \n                url, year_built, lot_size, days_on_market\n            ]\n        \n        # Handle other data formats or return placeholder data\n        return [\"Address not available\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\"]\n\n    def build_filter_state(property_type, min_price, max_price, min_beds, max_beds, min_baths, max_baths):\n        \"\"\"\n        Build the filter state for the Zillow search query.\n        \n        Args:\n            property_type (str): Type of property\n            min_price (int): Minimum price\n            max_price (int): Maximum price\n            min_beds (int): Minimum bedrooms\n            max_beds (int): Maximum bedrooms\n            min_baths (int): Minimum bathrooms\n            max_baths (int): Maximum bathrooms\n        \n        Returns:\n            dict: Filter state dictionary for Zillow search query\n        \"\"\"\n        filter_state = {\n            \"sortSelection\": {\"value\": \"globalRelevanceEx\"},\n            \"isAllHomes\": {\"value\": True}\n        }\n        \n        # Add property type filter\n        if property_type != \"all\":\n            property_type_map = {\n                \"house\": \"isHouse\",\n                \"apartment\": \"isApartment\",\n                \"condo\": \"isCondo\",\n                \"townhome\": \"isTownhouse\"\n            }\n            filter_state[property_type_map[property_type]] = {\"value\": True}\n        \n        # Add price filters\n        if min_price is not None and min_price > 0:\n            filter_state[\"price\"] = filter_state.get(\"price\", {})\n            filter_state[\"price\"][\"min\"] = min_price\n        \n        if max_price is not None and max_price > 0:\n            filter_state[\"price\"] = filter_state.get(\"price\", {})\n            filter_state[\"price\"][\"max\"] = max_price\n        \n        # Add bedroom filters\n        if min_beds is not None and min_beds > 0:\n            filter_state[\"beds\"] = filter_state.get(\"beds\", {})\n            filter_state[\"beds\"][\"min\"] = min_beds\n        \n        if max_beds is not None and max_beds > 0:\n            filter_state[\"beds\"] = filter_state.get(\"beds\", {})\n            filter_state[\"beds\"][\"max\"] = max_beds\n        \n        # Add bathroom filters\n        if min_baths is not None and min_baths > 0:\n            filter_state[\"baths\"] = filter_state.get(\"baths\", {})\n            filter_state[\"baths\"][\"min\"] = min_baths\n        \n        if max_baths is not None and max_baths > 0:\n            filter_state[\"baths\"] = filter_state.get(\"baths\", {})\n            filter_state[\"baths\"][\"max\"] = max_baths\n        \n        return filter_state\n\n    def get_sample_properties(search_location, property_type, min_price, max_price, \n                             min_beds, max_beds, min_baths, max_baths, limit):\n        \"\"\"\n        Generates sample property data based on the search parameters.\n        \n        Args:\n            search_location (str): Location to search\n            property_type (str): Type of property\n            min_price (int): Minimum price\n            max_price (int): Maximum price\n            min_beds (int): Minimum bedrooms\n            max_beds (int): Maximum bedrooms\n            min_baths (int): Minimum bathrooms\n            max_baths (int): Maximum bathrooms\n            limit (int): Maximum number of properties\n            \n        Returns:\n            list: List of property data lists\n        \"\"\"\n        properties = []\n        \n        # Set default min and max values if not provided\n        min_price = min_price or 200000\n        max_price = max_price or 2000000\n        min_beds = min_beds or 1\n        max_beds = max_beds or 5\n        min_baths = min_baths or 1\n        max_baths = max_baths or 4\n        \n        # Generate street names based on search location\n        streets = [\"Main St\", \"Oak Ave\", \"Maple Ln\", \"Cedar Dr\", \"Pine St\", \n                   \"Willow Way\", \"Elm St\", \"Washington Ave\", \"Broadway\", \"Park Pl\"]\n        \n        # Property types to use based on the input property_type\n        if property_type == \"all\":\n            types = [\"House\", \"Condo\", \"Apartment\", \"Townhome\"]\n        else:\n            types = [property_type.capitalize()]\n        \n        # Generate sample properties\n        for i in range(min(limit, 20)):\n            # Generate property details with realistic variations\n            price = min_price + (i * ((max_price - min_price) // 10)) + (i * 25000)\n            beds = min(max_beds, max(min_beds, 2 + (i % 4)))\n            baths = min(max_baths, max(min_baths, 1 + (i % 3) + 0.5 * (i % 2)))\n            sqft = 1000 + (beds * 250) + (i * 100)\n            \n            address = f\"{(i + 1) * 100} {streets[i % len(streets)]}, {search_location}\"\n            prop_type = types[i % len(types)]\n            year_built = 2023 - (i * 3) - (i % 10)\n            lot_size = f\"{0.1 + (i * 0.05):.2f} acres\"\n            days_on_market = 1 + (i * 3) + (i % 7)\n            \n            # Format values nicely for display\n            price_str = f\"${price:,}\"\n            sqft_str = f\"{sqft:,} sqft\"\n            baths_str = f\"{baths:.1f}\".rstrip('0').rstrip('.') if baths % 1 else f\"{int(baths)}\"\n            \n            properties.append([\n                address,\n                price_str,\n                str(beds),\n                baths_str,\n                sqft_str,\n                prop_type,\n                f\"https://www.zillow.com/homes/{i}-sample-{search_location.replace(' ', '-')}\",\n                str(year_built),\n                lot_size,\n                str(days_on_market)\n            ])\n        \n        return properties\n\n    # Configure proxy settings from the provided URL\n    proxy_url = \"brd.superproxy.io:33335\"\n    proxy_username = \"brd-customer-hl_28f1415f-zone-datacenter_proxy1-country-us\"\n    proxy_password = \"axp760dcafwz\"\n    \n    # Input validation\n    if not search_location or not isinstance(search_location, str):\n        raise ValueError(\"Search location must be a non-empty string\")\n    \n    if property_id is None and property_url is None and not search_location and not all([ne_lat, ne_long, sw_lat, sw_long]):\n        raise ValueError(\"Either search_location, property_id, property_url, or map coordinates must be provided\")\n    \n    if property_type not in [\"all\", \"house\", \"apartment\", \"condo\", \"townhome\"]:\n        raise ValueError(\"Property type must be one of: 'all', 'house', 'apartment', 'condo', or 'townhome'\")\n    \n    if search_type not in [\"for_sale\", \"for_rent\", \"sold\"]:\n        raise ValueError(\"Search type must be one of: 'for_sale', 'for_rent', or 'sold'\")\n    \n    if not isinstance(limit, int) or limit < 1 or limit > 50:\n        raise ValueError(\"Limit must be an integer between 1 and 50\")\n    \n    # Format the result as a 2D list with header row\n    result = [\n        [\"Address\", \"Price\", \"Bedrooms\", \"Bathrooms\", \"Square Footage\", \n         \"Property Type\", \"Zillow URL\", \"Year Built\", \"Lot Size\", \"Days on Market\"]\n    ]\n    \n    # Determine which type of search to perform\n    try:\n        # Initialize property data collection\n        properties = []\n        \n        # CASE 1: Search by specific property ID\n        if property_id:\n            data = get_property_by_id(property_id)\n            if data:\n                properties.append(format_property_data(data))\n        \n        # CASE 2: Search by specific property URL\n        elif property_url:\n            data = get_property_by_url(property_url)\n            if data:\n                properties.append(format_property_data(data))\n        \n        # CASE 3: Search by location or coordinates\n        else:\n            # Set default coordinates if not provided\n            if not all([ne_lat, ne_long, sw_lat, sw_long]):\n                # Default coordinates covering the continental US\n                ne_lat = 49.3457868  # Northern boundary\n                ne_long = -66.9513812  # Eastern boundary\n                sw_lat = 24.396308  # Southern boundary\n                sw_long = -125.0  # Western boundary\n            \n            # Perform the search based on the search type\n            properties = search_properties(\n                search_type, search_location, property_type, \n                min_beds, max_beds, min_baths, max_baths, min_price, max_price,\n                ne_lat, ne_long, sw_lat, sw_long, zoom_value, limit\n            )\n            \n        # Add properties to result, respecting the limit\n        for i, prop_data in enumerate(properties):\n            if i >= limit:\n                break\n            result.append(prop_data)\n        \n        # If no properties found, provide a message\n        if len(result) == 1:\n            result.append([\"No properties found matching your criteria\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"])\n            \n    except Exception as e:\n        # If the request fails, fall back to sample data\n        print(f\"Error fetching Zillow data: {str(e)}\")\n        properties = get_sample_properties(search_location, property_type, min_price, max_price, \n                                          min_beds, max_beds, min_baths, max_baths, limit)\n        result.extend(properties)\n    \n    return result",
    "test_cases": [
      {
        "id": "test_basic_search",
        "description": "Basic search for properties in Seattle",
        "arguments": {
          "search_location": "Seattle, WA"
        },
        "expected_rows": 11,
        "demo": true
      },
      {
        "id": "test_house_with_filters",
        "description": "Search for houses in San Francisco with price and bedroom filters",
        "arguments": {
          "search_location": "San Francisco, CA",
          "property_type": "house",
          "min_price": 500000,
          "max_price": 1500000,
          "min_beds": 3,
          "max_beds": 4
        },
        "expected_rows": 11,
        "demo": true
      },
      {
        "id": "test_condo_with_bathroom_filters",
        "description": "Search for condos in New York with bathroom filters",
        "arguments": {
          "search_location": "New York, NY",
          "property_type": "condo",
          "min_baths": 2,
          "max_baths": 3,
          "limit": 5
        },
        "expected_rows": 6,
        "demo": true
      },
      {
        "id": "test_zip_code_search",
        "description": "Search properties in a specific zip code",
        "arguments": {
          "search_location": "90210",
          "limit": 3
        },
        "expected_rows": 4,
        "demo": true
      }
    ],
    "fileId": "1",
    "link": "https://www.boardflare.com/resources/python-functions/web\\zillow/zillow"
  }
]